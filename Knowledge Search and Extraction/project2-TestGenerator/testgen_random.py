from typing import List, Tuple
import argparse
import random
from event_generator import EventGenerator
from archive_testcase import Archive, TestCase
from tools import generate_tests

# HYPERPARAMETERS
POOL_SIZE = 1000
N = 2000
        
class TestPool(EventGenerator):
    def __init__(self, input_types: List[str], pool_size: int = POOL_SIZE, min_int: int = None, max_int: int = None, max_string_length: int = None):
        super(TestPool, self).__init__(input_types, min_int, max_int, max_string_length)
        self.pools = []
        self.pool_size = pool_size
        self._generate_pools()
        
    def get_pool_size(self) -> int:
        return self.pool_size
    
    def _add_new_input(self, input: Tuple, is_counting: bool = True):
        self.pools.append(input)
        if is_counting:
            self.pool_size += 1

    def _generate_random_input(self, is_counting: bool = True) -> Tuple:
        input = super(TestPool, self).generate_random_input()
        self._add_new_input(input, is_counting=is_counting)
        return input

    def _generate_pools(self):
        for _ in range(self.pool_size):
            self._generate_random_input(is_counting=False)
    
    def _mutation(self):
        input = self.pools[random.randint(0, self.pool_size - 1)]
        new_input = super(TestPool, self).mutate_input(input)
        self._add_new_input(new_input)
        return new_input

    def _crossover(self):
        idx0, idx1 = random.sample(range(self.pool_size), 2)
        input0 = self.pools[idx0]
        input1 = self.pools[idx1]
        new_inputs = super(TestPool, self).crossover_inputs(input0, input1)

        for new_input in new_inputs:
            self._add_new_input(new_input)
        return new_inputs

    def stochastic_generation(self, log: bool = False):
        choice = random.choice([0,1,2])
        gen = None
        match choice:
            case 0:
                gen = [self._generate_random_input()]
            case 1:
                gen = [self._mutation()]
            case 2:
                gen = self._crossover()

        if log:
            mp = {0: 'Random generation', 1: 'Mutation', 2: 'Crossover'}
            print(f'Generated by {mp[choice]}')
            print(f'Generated input{"s" if choice==2 else ""}: {gen}')
            print(f'Current pool size: {self.pool_size}')
        return gen


def fuzz_N_times(archive: Archive, fn_name: str, arg_types: List[str], arg_names: List[str], num_branches: int, N: int = N, full_condition_coverage_stop: bool = True, **kwargs) -> Archive:
    if arg_types == ['str', 'int']:
        arg_types = ['kv']
    pool = TestPool(arg_types, **kwargs)
    full_condition_coverage = False
    archive.add_fn(fn_name, num_branches)
    while N > 0 and not full_condition_coverage:
        for input in pool.stochastic_generation():
            testcase = TestCase(arg_types, arg_names, input)
            stopper = archive.consider_fn_testcase(fn_name, testcase)
            if full_condition_coverage_stop:
                full_condition_coverage = stopper
            N -= 1
            if full_condition_coverage:
                break
    return archive
         


if __name__ == "__main__":
    
    parser = argparse.ArgumentParser(description='Generate tests from instrumented scripts.')
    parser.add_argument('instrumented_files_dir_path', type=str, help='Path to directory containing instrumented files.')
    parser.add_argument('original_files_dir_path', type=str, help='Path to directory containing original files.')
    parser.add_argument('output_tests_dir_path', type=str, help='Path to directory where tests will be saved.')
    parser.add_argument("--delta", type=float, default=1e-7, help="Delta value for float comparison.")
    parser.add_argument("--kwargs", nargs="*", help="Additional keyword arguments in the form key=value, for TestPool constructor. See pool.py for defaults.")
    args = parser.parse_args()

    kwargs = {}
    if args.kwargs:
        for arg in args.kwargs:
            key, value = arg.split('=')
            kwargs[key] = int(value)
    
    generate_tests(fuzz_N_times, args.instrumented_files_dir_path, args.original_files_dir_path, args.output_tests_dir_path, delta=args.delta, **kwargs)

    

            
