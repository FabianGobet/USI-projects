# -*- coding: utf-8 -*-
"""Numerical Algorithms - assignment 4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LqjtgtjKUBDAyBCPHKaAwHWXrPq_fjiM
"""

"""
In order to compute the sin and cos fuction we need to use the the 'math' librabry, python does not have in-built cos and sin functions.
Furthermore, in order to plot my findings and to time the algorithms I need to use the matplotlib and time libraries, respectively.
It's noteworty taht i did not employ the use of numpy, such that all vector operations are done using lists an appropirate logic.

"""
import matplotlib.pyplot as plt
import time
import math

"""
To generate a set of equidistant t for a given interval with n+1 elements, I've ccrated the 'get_interval' function.
the function 'func' computes f(t), the function from the exercise sheet.
The function 'get_data_points' computes f(t) for all t in a list.

"""
def get_interval(divisions,min_value=-1,max_value=1):
  return [((max_value-min_value)*j/divisions + min_value) for j in range(divisions+1)]

def func(t):
  k = 25*(t**2) + 1
  v = [math.sin(t*math.pi/2), math.cos(t*math.pi/2)]
  return [j*(k+1)/k for j in v]

def get_data_points(t_vec):
  x_y = [func(t) for t in t_vec]
  return x_y

"""
The function 'neville' computes Neville's algorithm for a given value t, according to the set 'ti' and its corresponding elements P such that func(ti[i]) = P[i].
The value 'n' is generated according to the size of 'ti'.

"""

def neville(ti,t,P):
  Q = P.copy()
  n = len(ti)
  for j in range(1,n):
    for i in range(0,n-j):
      a = (ti[i+j] - t)/(ti[i+j]-ti[i])
      b = (t- ti[i])/(ti[i+j]-ti[i])
      Q[i] = [a*Q[i][idx] + b*Q[i+1][idx] for idx in range(len(Q[i]))]
  return Q[0]

"""
def get_chebyshev_nodes(n, min_value=-1, max_value=1):
    return [0.5 * (min_value + max_value) + 0.5 * (max_value - min_value) * math.cos((2*k-1) * math.pi / (2*n)) for k in range(1, n+1)]

n = 50
m = 1000
interval = get_chebyshev_nodes(n)
points = get_data_points(interval)
interval2 = get_interval(m)
points_by_nev = [neville(n,interval,i,points) for i in interval2]
x = [v[0] for v in points_by_nev]
y = [v[1] for v in points_by_nev]
plt.plot(x,y)
plt.show()
"""

"""
For the barycentric algorithm we have 2 distinct phases.
In the first phase we compute the vector 'W'. We only need to compute this vector once, and then calculate the points for the barycentric form using the same 'W'.
In the second phase we have the said barycentric algorithm which makes use of vector 'W'. Again, n is calculated according to the size of 'ti'. All inputs are equal to Neville's, for the exception of 'W'.

"""

def get_bary_W(ti):
  W = []
  n = len(ti)
  for i in range(n):
    w = 1.0
    for j in range(n):
      if j != i:
        w = w / (ti[i] - ti[j])
    W.append(w)
  return W

def barycentric(ti,t,P,W):
  n = len(ti)
  Q = P.copy()
  point_size = len(Q[0])
  N = [0.0 for i in range(point_size)]
  D = 0.0

  for i in range(n):
    if t == ti[i]:
      return Q[i]
    else:
        w = W[i] / (t - ti[i])
        N = [N[j] + w*Q[i][j] for j in range(point_size)]
        D = D + w
  return [N[j]/D for j in range(point_size)]

"""
For the newtons algorithm we have 2 distinct phases.
In the first phase we compute the dividing differences while caching them so we don't waste computation time recursively calculating the same numbers. This technique is known as memoization.
At the end of the first phase we get a vector 'B' which then will be needed for the actual newtons algorithm.
In the second phase we have the said newtonc algorithm which makes use of vector 'B'. Again, n is calculated according to the size of 'ti'.
The points computed by 'func' at each element of 'ti' were utilized to compute vector 'B'. Thus, all needed information is on 'B' and the only inputs we need are 'ti', 't' and 'B'.

"""

def get_newton_div_diffs(ti,P):

  cache = {}
  B = []
  point_size = len(P[0])
  n = len(ti)

  def rec(i,j,point_size,P,ti):
    if (i, j) in cache:
      return cache[(i, j)]
    if i==j:
      return P[i]
    else:
      t_diff = ti[j] - ti[i]
      result = [(rec(i+1,j,point_size,P,ti)[k]- rec(i,j-1,point_size,P,ti)[k])/t_diff for k in range(point_size)]
    cache[(i,j)] = result
    return result

  for i in range(n):
    B.append(rec(0,i,point_size,P,ti))
  return B


def newton_divdiff_form(ti,t,B):
  point_size = len(B[0])
  n = len(ti) - 1
  R = B[n].copy()
  for i in range(n-1,-1,-1):
    temp = t-ti[i]
    R = [R[k]*temp + B[i][k] for k in range(point_size)]

  return R

"""
The function 'get_algorithms_data', given an 'n', generated the interval and 'func' points, n+1 elements, and utilizes them com compute each of the algorithms for a given set of 'ti', in this case called 'interval'.
The results are then stored in a dictionary which I'll make use of in the plotting section.
Times for each computation are also recorded in the appropriate frames and saved into 'data'.

"""

def get_algorithms_data(n,interval):

  dic = {}
  ti = get_interval(n,-1,1)
  xy_f = get_data_points(ti)
  dic["ti_"+str(n)] = ti

  start = time.time()
  xy_nev = [neville(ti,i,xy_f) for i in interval]
  end = time.time()
  nev_time = end - start
  dic["xy_nev_"+str(n)] = xy_nev
  dic["nev_time_"+str(n)] = nev_time

  start = time.time()
  W = get_bary_W(ti)
  xy_bary = [barycentric(ti,i,xy_f,W) for i in interval]
  end = time.time()
  bary_time = end - start
  dic["xy_bary_"+str(n)] = xy_bary
  dic["bary_time_"+str(n)] = bary_time

  start = time.time()
  B = get_newton_div_diffs(ti,xy_f)
  xy_newt = [newton_divdiff_form(ti,i,B) for i in interval]
  end = time.time()
  newt_time = end - start
  dic["xy_newt_"+str(n)] = xy_newt
  dic["newt_time_"+str(n)] = newt_time

  return dic


"""
The 'plot_data' fuction takes in the data generated by the algorithms, a name for a specific algorithm and the original computed points of 'func' in an apropriate interval,
and plots the points of both the algorithm results for n = 10,20,40 and the original computed points

"""

def plot_data(data,xy_f_original,algorithm="nev"):
  names = {"nev":"Neville", "newt":"Newton", "bary":"Barycenter"}
  color_map = {10:'red', 20:'blue', 40:'green'}
  fig, axs = plt.subplots(2, 2)

  xf = [vec[0] for vec in xy_f_original]
  yf = [vec[1] for vec in xy_f_original]
  axs[0, 0].plot(xf, yf)
  axs[0, 0].set_title("f")

  for i in [10,20,40]:
    x = [vec[0] for vec in data["xy_"+algorithm+"_"+str(i)]]
    y = [vec[1] for vec in data["xy_"+algorithm+"_"+str(i)]]
    lab = names[algorithm]+str(i)+": "+str(data[algorithm+"_time_"+str(i)])+"s"
    ax = axs[0 if i == 10 else 1, 0 if i == 20 else 1]
    ax.plot(x, y)
    ax.set_title(lab, fontsize=10)
    if not (i == 10 and ax == axs[0,0]):
      ax.set_xlim([-1.1, 1.1])
      ax.set_ylim([-.1, 2.1])
  fig.tight_layout()

"""
Here im setting 'm' to 1000, which means we will generated a set of 'ti' with m+1 elements, equidistant, in the innterval of [-1, 1]
I then proceed to generate the evaluation of all 'ti' by 'func' and computeal the data I need, for n = 10,20,40, using the prior functions and saving it in the 'data' dictionary.

"""

m = 1000
interval = get_interval(m,-1,1)
xy_f_original = get_data_points(interval)
data = {}

for i in [10,20,40]:
  data.update(get_algorithms_data(i,interval))

"""
This plot shows 4 graphs of in a single image. In this case, we are plotting Neville's results and 'func'.
We also can see the times for n of the algorithm computation, besides the shape of it.

One thing that is noteworthy is that with higher degrees, all functions start to convert to a triangle like shape form with exploding values.
This phenomenon is known as Runge phenomenom and is typical of interpolations using equidistant points, which is the basis of this project.
The interpolations all pass by the given points to the algorithm, but in between them, the higher the degree used the bigger the oscilations. this oscilations also
tend to be higher around the borders of the interval.

One way to tackle this problem would be using Chebychevs points, which are computed using a cosine function, dont follow a uniform distribution and has higher density
near the borders of the interval.

The following piece of code can give a rough ideia of how chebychev points are generated and their result

def get_chebyshev_nodes(n, min_value=-1, max_value=1):
    return [0.5 * (min_value + max_value) + 0.5 * (max_value - min_value) * math.cos((2*k-1) * math.pi / (2*n)) for k in range(1, n+1)]

n = 50
m = 1000
interval = get_chebyshev_nodes(n)
points = get_data_points(interval)
interval2 = get_interval(m)
points_by_nev = [neville(n,interval,i,points) for i in interval2]
x = [v[0] for v in points_by_nev]
y = [v[1] for v in points_by_nev]
plt.plot(x,y)
plt.show()


Since this work wasn't specified in the script, I chose to leave it as comment, where the teacher may experiment if need be.

"""
plot_data(data,xy_f_original,algorithm="nev")

"""
The following plots to the same as the one before, except they are for the newton algorithm and the barycenter algorithm.

"""
plot_data(data,xy_f_original,algorithm="newt")

plot_data(data,xy_f_original,algorithm="bary")